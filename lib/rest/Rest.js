/*! letrest - v0.3.4 - 2016-07-20 */var CONFIG=require("../Config.js").getConfig(),ENTITIES=require("../Config.js").getEntities(),STRATEGY="",SCHEMA=require("../schema/Schema.js"),SECURITY=require("../security/Security.js"),SECURITY_CONTROLLER=require("../client/SecurityController.js").newInstance(),PROTOCOL=require("../protocol/Protocol.js"),DBManager=require("../database/DBManager.js"),MODULE="REST\t\t",LOG=require("uw-log").newInstance(MODULE),Q=require("q"),Mapper=function(a){var b=function(b){if(!a.notUseToken&&!b.letrest.session)throw new Error("Not a valid token session. This should not happened")},c=function(a,b){var c=Q.defer();try{c.resolve(b[a](b))}catch(b){LOG.info("Failed to execute "+a+"-aggregate function"),c.reject(b)}return c.promise},d=function(a){return a},e=function(a){a.res.send(PROTOCOL.success(a.entity,a.mode,a.arr))},f=function(a,b){LOG.error("Service failed",b.toString());var c=PROTOCOL.getError(b);a.res.status(c.code).send(c)},g=function(a,g,h){this.service=function(i,j){LOG.info("Executing ALL request for entity =>",a.table);var k={};try{b(i),k.pre=g||d,k.post=h||d,k.entity=a,k.req=i,k.res=j,k.mode="all",k.DB=DBManager.newInstance().init(a),k.SecurityController=SECURITY_CONTROLLER,k.DB.connection.open().then(c.bind(null,"pre",k)).then(function(a){return k.DB.strategy.select(a)}).then(c.bind(null,"post")).then(e).then(k.DB.finish).catch(function(a){f(k,a);try{k.DB.finish()}catch(a){LOG.error(a)}})}catch(a){LOG.error("Failed to validate session.",a.toString()),j.status(500).send(PROTOCOL.serverError(a))}}},h=function(a,g,h){this.service=function(i,j){var k=function(a){if(0==a.arr.length)throw a.res.status(404).send(PROTOCOL.notFound()),new Error("");return a};LOG.info("Executing GET request for entity =>",a.table);var l={};try{b(i),l.pre=g||d,l.post=h||d,l.entity=a,l.req=i,l.res=j,l.mode="get",l.DB=DBManager.newInstance().init(a),l.SecurityController=SECURITY_CONTROLLER,l.DB.connection.open().then(c.bind(null,"pre",l)).then(l.DB.strategy.select).then(k).then(c.bind(null,"post")).then(e).then(l.DB.finish).catch(function(a){f(l,a);try{l.DB.finish()}catch(a){LOG.error(a)}})}catch(a){LOG.error("Failed to process query",a),j.status(500).send(PROTOCOL.serverError(a))}}},i=function(a,g,h){this.service=function(i,j){LOG.info("Executing POST request for entity =>",a.table);var k={};try{b(i),k.pre=g||d,k.post=h||d,k.entity=a,k.req=i,k.res=j,k.mode="post",k.SecurityController=SECURITY_CONTROLLER;var l=SCHEMA.validate(a,i.body);LOG.verbose("Validation result",l),l.errors.length>0?j.status(400).send(PROTOCOL.validationError(l.errors)):(k.DB=DBManager.newInstance().init(a),k.DB.initTransaction().then(c.bind(null,"pre",k)).then(k.DB.strategy.insert).then(c.bind(null,"post")).then(k.DB.connection.commit).then(k.DB.finish).then(e.bind(null,k)).catch(function(a){f(k,a);try{k.DB.rollbackAndFinish()}catch(a){LOG.error(a)}}))}catch(a){LOG.error("Failed to process query because of =>",a.toString()),j.status(500).send(PROTOCOL.serverError(a))}}},j=function(a,b,g){this.service=function(h,i){LOG.info("Executing PUT request for entity =>",a.table);var j={};try{j.pre=b||d,j.post=g||d,j.entity=a,j.req=h,j.res=i,j.mode="put",j.SecurityController=SECURITY_CONTROLLER;var k=SCHEMA.validate(a,h.body);k.errors.length>0?i.status(400).send(PROTOCOL.validationError(k.errors)):(j.DB=DBManager.newInstance().init(a),j.DB.initTransaction().then(c.bind(null,"pre",j)).then(j.DB.strategy.update).then(c.bind(null,"post")).then(j.DB.connection.commit).then(j.DB.finish).then(e.bind(null,j)).catch(function(a){f(j,a);try{j.DB.rollbackAndFinish()}catch(a){LOG.error(a)}}))}catch(a){LOG.error("Failed to validate session.",a);var l=PROTOCOL.serverError(a);i.status(l.code).send(l.msg)}}},k=function(a,b,g){this.service=function(h,i){LOG.info("Executing DELETE request for entity =>",a.table);var j={};try{j.pre=b||d,j.post=g||d,j.entity=a,j.req=h,j.res=i,j.mode="delete",j.DB=DBManager.newInstance().init(a),j.SecurityController=SECURITY_CONTROLLER,j.DB.initTransaction().then(c.bind(null,"pre",j)).then(j.DB.strategy.delete).then(c.bind(null,"post")).then(j.DB.connection.commit).then(j.DB.finish).then(e.bind(null,j)).catch(function(a){f(j,a);try{j.DB.rollbackAndFinish()}catch(a){LOG.error(a)}})}catch(a){LOG.error("Failed to process query ->",a.toString()),i.status(500).send(PROTOCOL.serverError(a))}}};this.createPath=function(b){if(a.path.indexOf("/",a.path.length-1)!==-1)throw new Error('The service path should not end with a "/"');switch(b){case"all":return a.path;case"post":return a.path+"/";case"put":case"get":case"delete":return a.path+"/"+CONFIG.pk_template}},this.map=function(b){var c=require("path"),d={all:g,get:h,post:i,put:j,delete:k};for(var e in a.service){LOG.info("- Configuring %s service",e.toUpperCase());var f=this.createPath(e),l=null,m=null;if(a.service[e].pre){var n=a.service[e].pre.split("@");LOG.info("\t- Mapping pre message '%s' in '%s'",n[0],n[1]),l=require(c.dirname(require.main.filename)+"/"+n[1])[n[0]]}if(a.service[e].post){var n=a.service[e].post.split("@");LOG.info("\t- Mapping post message '%s' in '%s'",n[0],n[1]),m=require(c.dirname(require.main.filename)+"/"+n[1])[n[0]]}var o=e;"all"==o&&(o="get");var p=a.service[e],q=SECURITY.secure(a,p);b.route(f)[o](q,new d[e](a,l,m).service)}}};exports.config=function(a){LOG.info("Configuring REST entities services");for(var b in ENTITIES){LOG.info("Mapping entity",b);var c=ENTITIES[b];new Mapper(c).map(a)}};